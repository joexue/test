
#include <linux/module.h>
#include <linux/version.h>
#include <linux/kernel.h>
#include <linux/proc_fs.h>
#include <linux/netlink.h>
#include <linux/delay.h>
#include <net/sock.h>

#include <asm/system.h>
#include <asm/io.h>
#include <asm/uaccess.h>

#include <linux/netdevice.h>
#include <linux/phy.h>
/* this head file is generated by openwrt makefile
 * when prepare to be built
 * */
/*
 * Change logs
 01 25, 2013	Removed the hardware version file support
 03 09, 2012    Added the new hardware platform ipocketusb support
 04 15, 2011    Changed to hotplug version
 02 15, 2011	Created by Joe
 */

/*
 * How to use the configuration button
 * This module will send the message kernel, and kernel will call
 * hotplug hen hotplug call the script located in /etc/hotplug.d
 * then we edit the relatived script to call user application
 * Two types of pressed 
 * 3 secs long time pressed
 * 3 times short time pressed
 * 5 times short time pressed
 * This module also created a file to indicate the hardware version(removed)
 */


MODULE_AUTHOR("Joe at Precidia");
MODULE_DESCRIPTION("Configuration button driver");
MODULE_LICENSE("GPL");
 
#define	REG	        (0x31060000)
#define	LEN		(0xff8)


#define ENET_RX_DESC 48
#define ENET_TX_DESC 16
struct netdata_local {
	struct platform_device	*pdev;
	struct net_device	*ndev;
	spinlock_t		lock;
	void __iomem		*net_base;
	unsigned long		net_region_start;
	unsigned long		net_region_size;
	u32			msg_enable;
	struct sk_buff		*skb[ENET_TX_DESC];
	unsigned int		last_tx_idx;
	unsigned int		num_used_tx_buffs;
	struct mii_bus		*mii_bus;
	struct phy_device	*phy_dev;
	struct clk		*clk;
	u32			dma_buff_base_p;
	u32			dma_buff_base_v;
	u32			dma_buff_size;
	u32			tx_desc_v [ENET_TX_DESC];
	u32			tx_stat_v [ENET_TX_DESC];
	u32			tx_buff_v [ENET_TX_DESC];
	u32			rx_desc_v [ENET_RX_DESC];
	u32			rx_stat_v [ENET_RX_DESC];
	u32			rx_buff_v [ENET_RX_DESC];
	struct lpc_net_cfg	*ncfg;
	int			link;
	int			speed;
	int			duplex;
};


static struct timer_list cb_timer;
int *preg=0;

static void button_check(unsigned long data)
{
	unsigned int *reg = (unsigned int *)data;
	printk("%d", *reg);
	mod_timer(&cb_timer, get_jiffies_64()+HZ/10);
}


int (* myread)(struct mii_bus *bus, int phy_id, int phyreg);

#define LPC_MCMD_READ				(1 << 0)
#define LPC_MIND_BUSY				(1 << 0)
#define LPC_ENET_MCMD(x)			(x + 0x024)
#define LPC_ENET_MADR(x)			(x + 0x028)
#define LPC_ENET_MIND(x)			(x + 0x034)
#define LPC_ENET_MRDD(x)			(x + 0x030)
static int lpc_mdio_read(struct mii_bus *bus, int phy_id, int phyreg)
{
	//printk("xxxxxxxxxxx ent\n" );
	//int lps = myread(bus, phy_id, phyreg);

	struct netdata_local *pldat = bus->priv;
	unsigned long timeout = jiffies + ((HZ * 100) / 1000); /* 100mS */
	int lps;

	writel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));
	writel(LPC_MCMD_READ, LPC_ENET_MCMD(pldat->net_base));

	/* Wait for unbusy status */
	while (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {
		//if (jiffies > timeout) {
		if (time_after(jiffies, timeout)) {
			//printk("yyyyyyyyyyyyyyy mind=%x, mrdd=%x\n", readl(LPC_ENET_MIND(pldat->net_base)), readl(LPC_ENET_MRDD(pldat->net_base)));
			printk("yyyyyyyyyyyyyyy mind=%x, mrdd=%x timeout=%u jiffies=%u\n", readl(LPC_ENET_MIND(pldat->net_base)), readl(LPC_ENET_MRDD(pldat->net_base)), timeout, jiffies);
			mdelay(100);
			printk("yyyyyyyyyyyyyyy mind=%x, mrdd=%x timeout=%u jiffies=%u\n", readl(LPC_ENET_MIND(pldat->net_base)), readl(LPC_ENET_MRDD(pldat->net_base)), timeout, jiffies);
			return -EIO;
		}
		cpu_relax();
	}

	lps = (int) readl(LPC_ENET_MRDD(pldat->net_base));
	writel(0, LPC_ENET_MCMD(pldat->net_base));
	
	//printk("xxxxxxxxxxx lps=%x jffies=%x\n", lps, jiffies);
	return lps;
}

static int __init dump_init_module(void)
{
	/* map the io space*/
	preg = (unsigned int *)ioremap(REG, LEN);
    	if(!preg)
		goto error1;

	int i;
	for(i=0; i<LEN/sizeof(int); i++) {
		if( 
			(REG+i*4) != 0x3106002C && 
			(REG+i*4) != 0x31060FE8 && 
			(REG+i*4) != 0x31060FEC && 
			(REG+i*4) != 0x31060038 && 
			(REG+i*4) != 0x3106003C && 
			(REG+i*4) != 0x3106003C && 
			(REG+i*4) != 0x31060208 && 
			(REG+i*4) != 0x3106020C && 
			(REG+i*4) != 0x31060ff0 && 
			!((REG+i*4) >= 0x3106004C && (REG+i*4) <= 0x310600FC) &&
			!((REG+i*4) >= 0x31060130 && (REG+i*4) <= 0x31060154) &&
			!((REG+i*4) >= 0x31060164 && (REG+i*4) <= 0x3106016c) &&
			!((REG+i*4) >= 0x31060178 && (REG+i*4) <= 0x310601fc) &&
			!((REG+i*4) >= 0x31060218 && (REG+i*4) <= 0x31060fdc) 
				)
		printk(KERN_ERR "0x%08x : 0x%08x\n", REG+i*4, *(preg+i));
	}
//	if(*(preg + 4/4) == 0x30 ) {
//		*(preg + 4/4) = 0x31;
//		printk(KERN_ERR "0x%08x : is changed\n", 4);
//	}
//	if(*(preg + 0x100/4) == 0x43 ) {
//		*(preg + 0x100/4) = 0x443;
//		printk(KERN_ERR "0x%08x : is changed\n", 0x100);
//	} 
//	if(*(preg + 8/4) == 0x12 ) {
//		*(preg + 8/4) = 0x15;
//		printk(KERN_ERR "0x%08x : is changed\n", 8);
//	}
//	if(*(preg + 0x18/4) == 0 ) {
//		*(preg + 0x18/4) = 0x100;
//		printk(KERN_ERR "0x%08x : is changed\n", 0x18);
//	} 
    	/* timer to get button event */

	struct net_device *dev;

	dev = first_net_device(&init_net);
	while (dev) {
		printk(KERN_INFO "found [%s]\n", dev->name);
		if(strcmp(dev->name, "eth0")==0) {
			printk("dev=%x\n", dev);
			break;
		}
		dev = next_net_device(dev);
	}

	struct netdata_local *pldat = netdev_priv(dev);
	struct phy_device *phydev = pldat->phy_dev;
	
	printk(KERN_ERR "phy link= %d pldat link=%d state=%d update=%d\n", phydev->link, pldat->link, phydev->state, phydev->drv->update_link);
//	if( phydev->link == 0)
//		phydev->link=1;
//	if( pldat->link == 0)
//		pldat->link=1;
//	if(phydev->state==10)
//		phydev->state=6;

//	this can let it live
//	phydev->state=10;
	//if(phydev->drv->update_link=0)
	//	phydev->drv->update_link=1;

	//this can let it live to
	//phy_start(phydev);

//	init_timer(&cb_timer);
//	cb_timer.function = button_check;
//	cb_timer.expires = get_jiffies_64() + HZ; 
//	cb_timer.data = &(phydev->drv->update_link);
//	add_timer(&cb_timer);

	//mod_timer(&cb_timer, get_jiffies_64()+HZ);
	myread = pldat->mii_bus->read;
	pldat->mii_bus->read = &lpc_mdio_read;

	return 0;
error1:
    	return -1;
} /* End of init_module() */


static void __exit dump_cleanup_module(void)
{
	if(preg)
		iounmap(preg);
	
	del_timer(&cb_timer);
} /* End of cleanup_module() */

module_init(dump_init_module);
module_exit(dump_cleanup_module);
